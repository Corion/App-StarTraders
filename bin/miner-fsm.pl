#!perl -w
use strict;
use Time::HiRes;

my @rules;

# Knowledge should be able to expire
# We need a rule debugger
# We also want groups of rules out of which only one will fire
# ... but other than that, other groups should still be able to modify state
#   Like "anxiety", which increases by rules and modifies the movement terriain
#   but which is only an observatorial rule setting a counter
# We need to store the dependencies, like current goal and the corresponding
# arrival event. Or maybe have (goal+distance) as a parameter instead
# (or even better, (goal+position) , for later non-abstract location)

# Framework
sub rule {
    my ($name, $predicates, $actions) = @_;
    push @rules, {
        predicates => $predicates,
        actions    => $actions,
        name       => $name,
    };
};

my $actor = {
    location => 'station',
    ship_state => 'docked',
    waypoints => [],
    cargo     => [],
    cooldown  => {},
    goal      => 'idle',
};

my @events;

sub predicate($$) {
    my ($name, $subref) = @_;
    return {
        name   => $name,
        predicate => $subref,
    };
};

# Predicates
sub is($$) {
    my ($slot,$value) = @_;
    $value = [$value] unless ref $value;
    predicate
        "is $slot in (@$value)",
        sub {
            die "Unknown slot $slot" unless exists $actor->{ $slot }; 
            my $msg = "Is $slot '$value'? " . (($actor->{ $slot }||'') eq $value ? "yes":"no");
            grep { ($actor->{ $slot }||'') eq $_ } @$value
        },
};

sub at($) {
    my $p = is location => $_[0];
    $p->{name} = "at $_[0]";
    $p
};

sub empty($) {
    my $slot = $_[0];
    predicate "empty $_[0]", sub {
        die "Unknown slot '$slot'" if not exists $actor->{ $slot };
        my $res = ref $actor->{ $slot } eq 'ARRAY'
            ? @{ $actor->{ $slot } } == 0
            :    $actor->{ $slot } || 0 == 0;
        #warn "$slot are " . ($res?'':'not') . " empty";
        $res
    };
};

sub has($) {
    my ($slot) = @_;
    predicate "has $slot", 
        _not( empty $slot )->{predicate}
}

sub _not($) {
    my $predicate = $_[0];
    my $p = predicate "not $predicate->{name}",
        sub {
            not $predicate->{predicate}->();
        };
};

# Actions
sub add($$) {
    my ($slot,$item) = @_;
    { name => "Add $item", code =>
        sub {
            unshift @{ $actor->{ $slot } }, $item
        },
    }
};

sub set($$) {
    my ($slot,$item) = @_;
    { name => "Set $slot to $item", code =>
        sub {
            $actor->{ $slot } = $item
        },
    },
};

sub perform ($) {
    my ($action) = @_;
    # Damn! We need to store the name too, so we can graph the thing!
    # We also need to turn the code into data. If there is a queue
    # generated by events, we don't want that queue in code, but as a
    # sequence of actions
    return { name => $action,
      code => sub {
            print "-->$action\n";
            no strict 'refs';
            goto &$action;
        },
    }
};

sub add_event {
    push @events, [@_];
    @events = sort { $a->[0] <=> $b->[0] } @events
};

# Should we do an "stat available" event
# or should we have "stat is available after time $x"?
sub cooldown ($$$) {
    my ($kind, $span, $then) = @_;
    my $ts = time  + $span;
    add_event( $ts, $then, $actor );
};

# Should we have a proper (sorted, insertable) priority queue
# for events?
sub undock {
    print "Starting to undock\n";
    set( ship_state => 'undocking')->{code}->();
    # What happens if the ship gets destroyed before it is undocked?
    # The cooldown would then fire and mess up the ship state
    # Maybe such events should get attached to their respective object(s)
    # Also, there need to be different dimensions of state
    # location / cargo-action / ... ?
    cooldown ship_state => 2, sub {
        #print "Undocked";
        set( ship_state => 'undocked' )->{code}->();
    };
};

sub dock {
    print "Starting to dock\n";
    set( ship_state => 'docking')->{code}->();
    # What happens if the ship gets destroyed before it is undocked?
    # The cooldown would then fire and mess up the ship state
    cooldown ship_state => 2, sub {
        #print "Docked";
        set( ship_state => 'docked' )->{code}->();
    };
};

sub sell {
    print "Selling cargo\n";
    set( cargo => [] )->{code}->();
};

sub move_to_waypoint {
    set( ship_state => 'moving' )->{code}->();
    my $wp = $actor->{waypoints}->[0];
    # What happens if the ship gets destroyed before it arrives?
    # The cooldown would then fire and mess up the ship state
    # We need to not store callbacks but the parameters for that
    # so we can eliminate/update all future events for an object that gets
    # destroyed/changed mid-flight
    print "Arrival at $wp in 5\n";
    set location => 'en_route';
    cooldown ship_state => 5, sub {
        set( ship_state => 'floating' )->{code}->();
        # Ugh - what if we changed our waypoint half-way? 
        set( location => $wp )->{code}->();
        shift @{ $actor->{ waypoints } };
    };
};

sub mine {
    print "Starting to mine\n";
    set( ship_state => 'mining')->{code}->();
    # What happens if the ship gets destroyed before it is undocked?
    # The cooldown would then fire and mess up the ship state
    # We need to clean out pending states on object destruction
    cooldown ship_state => 7, sub {
        #print "Full";
        set( ship_state => 'floating' )->{code}->();
        add( cargo => [ 100, 'minerals' ] )->{code}->();
    };
};

# Ruleset
# Maybe we can outline the sequences using graphviz, interactively, to show
# which rules fire in succession?
rule do_undock => [ (has 'waypoints'), (is 'ship_state' => 'docked') ]
    => [
         perform 'undock',
       ],
    ;

rule do_start_travel => [
    (has 'waypoints'),
    (is 'ship_state' => ['floating','undocked']),
] => [
    perform 'move_to_waypoint',
];

rule do_travel => [
    (is 'ship_state' => 'moving'), (at 'en_route'),
] => [
    # wait
    # idle?
    # "continue"?
];

rule at_station_empty => [ at 'station', empty 'cargo', empty 'waypoints' ]
    => [ (add waypoints => 'asteroids'),
         set goal => 'mine',
       ],
    ;

# An "is_idle" predicate would be convenient
rule at_asteroids_empty => [ at 'asteroids', empty 'cargo', empty 'waypoints', is 'ship_state', 'floating' ]
    => [ perform 'mine',
       ],
    ;

rule at_asteroids_full => [ at 'asteroids', has 'cargo', empty 'waypoints' ]
    => [ (add waypoints => 'station'),
         set goal => 'sell',
       ],
    ;

rule at_station_full => [ at 'station', has 'cargo', empty 'waypoints', is 'ship_state', 'floating' ]
    => [ perform 'dock' ],
    ;

rule docked_at_station_full => [ at 'station', has 'cargo', empty 'waypoints', is 'ship_state', 'docked' ]
    => [ perform 'sell', ],
    ;

sub write_graphviz {
    my( $filename )= @_;
    use GraphViz2;
    my $g= GraphViz2->new(
        global => { directed => 1 },
    );
    
    for my $rule ( @rules ) {
        # Add if/else checks for each used predicate to the edge
        # Add intermediate states for each modification like set
        
        use Data::Dumper;
        (my $action)= grep {
            #warn $_;
            #warn $_->{name};
            1
        } @{$rule->{actions}};
        
        # XXX We only use the first perform...
        (my $target)= grep {
            $_->{name} eq 'perform'
        } @{$rule->{actions}};
        (my $source_state)= grep {
                $_->{attr} eq 'ship_state'
            and $_->{name} eq 'is'
        } @{$rule->{prerequisites}};
        warn Dumper $rule;
        
        warn sprintf '%s uses %s', $rule->{name}, $action->{name};
        warn sprintf '%s goes to %s', $rule->{name}, $target->{name}
            if $target;
        
        # push_subgraph for intermediate nodes
        $g->add_edge( 
            from => $rule->{name},
            # Perform( = goto?)
            label => $action->{name},
            to => $target->{name},
        );
    };
    
    $g->run( format => 'svg', output_file => $filename );
}

sub run {
    my $last= 0;
    while (1) {
        print "\@$actor->{location} ($actor->{ship_state}) [$actor->{goal}]\n";
        # Fire all events that fire now
        my $now = time;
        if( $now == $last ) {
            sleep 0.1;
            next;
        };
        $last= $now;
        my @now = grep { $_->[0] <= $now } @events;
        for my $ev (@now) {
            #warn "Event $ev";
            $ev->[1]->();
        };
        @events = grep { $_->[0] > $now } @events;
        # Find a rule that applies to our actor
        RULE: for my $rule (@rules) {
            my $pc = 0;
            for my $p (@{$rule->{predicates}}) {
                my $res = $p->{predicate}->();
                if (! $res) {
                    next RULE;
                };
            };
            $pc++;
            #print "$pc: Firing rule $rule->{name}\n";
            for my $a (@{ $rule->{ actions }}) {
                #warn "Running $a->{name}";
                my $nextstate = $a->{code}->();
                #warn $nextstate;
            };
            # First matching rule overrides all others
            last RULE;
        };
        sleep 1;
    };
};

#write_graphviz('structure.svg');
#exit;
run;